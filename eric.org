#+TITLE: Eric Skoglunds Emacs Configuration
#+OPTIONS: toc:1 h:4

Inspired by:
  - [[https://github.com/mm--/dot-emacs/blob/master/jmm-emacs.org][Josh Moller-Mara's configuration]]
  - [[https://github.com/sachac/.emacs.d/][Sacha Chuas configuration]]
  - [[https://github.com/dakrone/eos][The Emacs Operating system]]

* Emacs initialization
** Visual distractions

I don't want to see any startup messages or the splash screen.
I also want to remove the scroll, menu and tool bars.
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t)
(setq inhibit-startup-message t)
(scroll-bar-mode -1)
(menu-bar-mode -1)
(tool-bar-mode -1)
#+END_SRC
** Packages and Elisp management
*** Load path setup

All the directories where we look for packages sources and other elisp files
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/emacs.d/elpa")
(add-to-list 'load-path "~/.emacs.d/themes")
(add-to-list 'load-path "~/.emacs.d/elisp")
#+END_SRC

*** Package setup
We need to require the package library first and then initialize it so that we can
load and install the packages we want. After that we setup the repositories that we
want to get packages from.
#+BEGIN_SRC emacs-lisp
(require 'package)
(package-initialize)
(setq package-archives
      '(("melpa" . "http://melpa.org/packages/")
        ("org" . "http://orgmode.org/elpa/")
        ("gnu" . "http://elpa.gnu.org/packages/")))
#+END_SRC

We are now able to require and install the programs that we need.
First we need to check that all the packages that we want to use are
installed and if they aren't we need to install them. To add a package
just add it att the end of the `my-packages` list.

#+BEGIN_SRC emacs-lisp
  (require 'cl)
  (defvar my-packages
    '(ag
      async
      avy
      cargo
      company
      company-go
      diminish
      elfeed
      expand-region
      flycheck
      flycheck-rust
      helm
      helm-ag
      helm-projectile
      magit
      multiple-cursors
      nyan-mode
      org-plus-contrib
      paredit
      projectile
      racer
      rust-mode
      smart-mode-line
      solarized-theme
      spacemacs-theme
      switch-window
      undo-tree
      use-package
      xref-js2
      yasnippet))

  (when (not package-archive-contents)
    (package-refresh-contents))

  (defun my-packages-installed-p ()
    (loop for p in my-packages
          when (not (package-installed-p p)) do (return nil)
          finally (return t)))

  (unless (my-packages-installed-p)
    ;; check for new packages (package versions)
    (message "Refreshing Package Contents")
    (package-refresh-contents)
    (message "Installing missing packages")
    ;; install the missing packages
    (dolist (p my-packages)
      (when (not (package-installed-p p))
        (package-install p))))

  (setq use-package-verbose t)
  (require 'use-package)
  (use-package auto-compile
    :ensure t
    :config (auto-compile-on-load-mode))
  (setq load-prefer-newer t)
#+END_SRC

** Require packages
One unified place to require most of the packages that we use.

#+BEGIN_SRC emacs-lisp
(require 'org)
(require 'org-drill)
#+END_SRC

We also want to require some files that I've created myself, let's do that seperatly for ease of maintenance.

#+BEGIN_SRC emacs-lisp
(require 'eel)
#+END_SRC

** Color theme
We can now load our color theme!
#+BEGIN_SRC emacs-lisp
(load-theme 'spacemacs-dark t)
#+END_SRC

*** Source file modes configuration
Configure what modes files will be open in. Our default mode is /not/ *fundamental*
but *org-mode* since everything should really just be org files!

#+BEGIN_SRC emacs-lisp
(setq-default major-mode 'org-mode)
#+END_SRC

Next we need to configure which mode we choose for different file endings.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.pro\\'" . prolog-mode))
  (add-to-list 'auto-mode-alist '("\\.erl\\'" . erlang-mode))
  (add-to-list 'auto-mode-alist '("\\.cl\\'" . common-lisp-mode))
  (add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\|txt\\)$" . org-mode))
#+END_SRC

** Mac specific
Set the option key as meta if we are on a mac
#+BEGIN_SRC emacs-lisp
    (if (string= system-type "darwin")
        (progn
          (setq mac-command-modifier 'meta)
          (setq mac-option-modifier 'meta)
          (setq mac-right-option-modifier nil)))

  (when (memq window-system '(max ns))
    (setq exec-path-from-shell-check-startup-files nil)
    (exec-path-from-shell-initialize)
  (exec-path-from-shell-copy-envs '("PATH")))
#+END_SRC
* Basic Configuration
First of all we don't need to have any disabled commands that emacs doesn't think
we should use...

And we really don't want to be typing `yes` or `no` all the time but want to use `y` and `n`.

#+BEGIN_SRC emacs-lisp
(setq disabled-command-function nil)
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

I *hate* blinking cursors so that needs to go!
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
#+END_SRC

I also have a couple configurations for some of the built in stuff, either enabling or
disabling stuff i use or don't use.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  (column-number-mode 1)
  (show-paren-mode 1)
  (setq show-paren-delay 0)
  (global-visual-line-mode 1)
  (global-linum-mode 1)
  (column-number-mode t)
  (electric-pair-mode t)
  (electric-indent-mode t)
  (global-font-lock-mode t)
  (global-auto-revert-mode t)
  (nyan-mode t)
  (setq kill-emacs-query-functions
        (cons (lambda () (yes-or-no-p "Really kill emacs?"))
              kill-emacs-query-functions))
#+END_SRC
** Backups and autosaving
Emacs usually puts backup files in the same directory as the current buffer.
I like to have them colected into one directory in my .emacs.d directory.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC

We save all, save version controlled. We have terrabytes of storage and don't want
to lose anything ever!

#+BEGIN_SRC emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+END_SRC

Emacs doesn't seem to create the autosave folder for us so let's do that if it doesn't
exist.

#+BEGIN_SRC emacs-lisp
(make-directory "~/.emacs.d/autosaves" t)
#+END_SRC

** Keymappings
#+BEGIN_SRC emacs-lisp
;; General
(global-set-key "\C-xp"         'replace-string)
(global-set-key (kbd "C-c r")   'comment-region)
(global-set-key (kbd "C-c u")   'uncomment-region)
(global-set-key (kbd "C-c s")   'eshell)
;; eel related bindings
(global-set-key (kbd "C-c C-d") 'eel/duplicate-line)
(global-set-key (kbd "C-c f")   'eel/copy-filename-to-killring)
(global-set-key (kbd "C-h C-s") 'eel/switch-to-scratch)
;; Org-mode related bindings
(global-set-key (kbd "C-c c")   'org-capture)
(global-set-key (kbd "C-c a")   'org-agenda)
(global-set-key (kbd "C-c l")   'org-store-link)
(global-set-key (kbd "C-c i")   'org-clock-in)
(global-set-key (kbd "C-c o")   'org-clock-out)
#+END_SRC
** Useful snippets

Taken from emacsrocks

#+BEGIN_SRC emacs-lisp
(defadvice sgml-delete-tag (after reindent-buffer activate)
  (cleanup-buffer))
#+END_SRC

#+END_SRC
** Whitespace things
#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'whitespace-cleanup)
#+END_SRC
* Autocomplete configuration
For autocomplete I use company-mode
#+BEGIN_SRC emacs-lisp
  (use-package company
    :config
    (add-hook 'after-init-hook 'global-company-mode))
#+END_SRC

yasnippet for some neat little snippet action
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :diminish yas-minor-mode
    :init (yas-global-mode)
    :config (yas-global-mode 1))
#+END_SRC

and finally flycheck for on the fly syntax checking
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :init (global-flycheck-mode))
#+END_SRC
* Undo tree mode
Undo tree is a nice package that let's us have a bit more powerfull undoing in Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :diminish undo-tree-mode
    :config
    (progn
      (global-undo-tree-mode)
      (setq undo-tree-visualizer-timestamps t)
      (setq undo-tree-visualizer-diff t)))
#+END_SRC
* Helm and projectile
Helm is a cool system for completion and file navigation, I use this in conjunction with projectile for
project management.

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :diminish helm-mode
    :init
    (progn
      (require 'helm-config)
      (setq helm-candidate-number-limit 100)
      (setq helm-idle-delay 0.0
            helm-input-idle-delay 0.01
            helm-buffers-fuzzy-matching t
            helm-recentf-fuzzy-match t
            helm-M-x-fuzzy-match t
            helm-quick-update t
            helm-M-x-requires-pattern nil
            helm-ff-skip-boring-files t)
      (helm-mode)
      (helm-autoresize-mode t))
    :bind (("C-c h"   . helm-mini)
           ("C-x f"   . helm-for-files)
           ("C-h a"   . helm-apropos)
           ("C-x C-b" . helm-buffers-list)
           ("C-x b"   . helm-buffers-list)
           ("C-x c o" . helm-occur)
           ("M-y"     . helm-show-kill-ring)
           ("M-x"     . helm-M-x)))
#+END_SRC

Projectile is */the/* system for working with projects in emacs!
We want to configure it to use helm because awesome + awesome = more awesomeness

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :config
    (progn
      (setq projectile-keymap-prefix (kbd "C-c p"))
      (setq projectile-completion-system 'default)
      (setq projectile-enable-caching t)
      (setq projectile-indexing-method 'alien)
      (add-to-list 'projectile-globally-ignored-files "node-modules"))
    :config
    (projectile-global-mode))

  (use-package helm-projectile)
#+END_SRC

* Selecting
** Multiple Cursors
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :bind (("C-. l" . mc/edit-lines)
           ("C-. a" . mc/mark-all-like-this)
           ("M-n"   . mc/mark-next-like-this)
           ("M-p"   . mc/mark-previous-like-this)))
#+END_SRC
** Expand region
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind (("C--" . er/expand-region)))
#+END_SRC
* Moving Around
** Avy mode
Avy allows us to quickly jump in our buffers
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :bind (("M-g j" . avy-goto-char)
           ("M-g w" . avy-goto-word-1)
           ("M-g l" . avy-goto-line))
    :config
    (avy-setup-default))
#+END_SRC

Let's also use avy for zapping to chars!
#+BEGIN_SRC emacs-lisp
  (use-package avy-zap
    :bind (("M-z" . avy-zap-up-to-char-dwim)
           ("M-Z" . avy-zpa-to-char-dwim)))
#+END_SRC
** Switching window
#+BEGIN_SRC emacs-lisp
  (use-package switch-window
    :bind (("C-x o" . switch-window)))
#+END_SRC
* Programming Languages
** Lisp configuration
Since we're using emacs, configuration related to LISP gets its own section!

#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :config
    (progn
      (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
      (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
      (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
      (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
      (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
      (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)))
#+END_SRC
*** Emacs Lisp

Emacs lisp is the language that is used within emacs. Emacs comes with two documents
documenting the language and emacs specific concepts.

   1. [[info:eintr#Top][Emacs lisp intro]]
   2. [[info:dir#Top][Emacs Lisp Reference]]
#+BEGIN_SRC emacs-lisp
(use-package "eldoc"
  :diminish eldoc-mode
  :commands turn-on-eldoc-mode
  :defer t
  :init
  (progn
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)))
#+END_SRC
** Rust
We use rust mode and the cargo minor mode. There is also the rustfmt package
#+BEGIN_SRC emacs-lisp
  (add-hook 'rust-mode-hook 'cargo-minor-mode)
  (add-hook 'rust-mode-hook (lambda ()
                              (local-set-key
                               (kbd "C-c <tab>" #'rust-format-buffer))))
#+END_SRC

Racer is the code completion and source code navigation tool for rust.
We can use it to get nice code completion with company-mode.

#+BEGIN_SRC emacs-lisp
  (setq racer-cmd "~/.cargo/bin/racer")
  (setq racer-rust-src-path "~/programming/open-source/rust/src")

  (add-hook 'rust-mode-hook #'racer-mode)
  (add-hook 'racer-mode-hook #'eldoc-mode)
  (add-hook 'racer-mode-hook #'company-mode)
  (add-hook 'flycheck-mode-hook #'flycheck-rust-setup)
#+END_SRC
** Go
Enable company-go as the backend for company-mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'go-mode-hook
            (lambda ()
              (set (make-local-variable 'company-backends) '(company-go))
              (company-mode)))
#+END_SRC
** Javascript
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
           :init
           (add-hook 'js2-mode-hook #'js2-refactor-mode)
           (add-hook 'js2-mode-hook (lambda ()
                                      (add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t)))
           (js2r-add-keybindings-with-prefix "C-c C-r")
           :bind (
                  :map js2-mode-map
                       ("C-k" . js2r-kill)))
  (require 'xref-js2)

  (define-key js-mode-map (kbd "M-.") nil)
#+END_SRC
We'll be using js2 mode since it is superior to javascript-mode.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
  (add-to-list 'auto-mode-alist '("\\.jsm\\'" . js2-mode))
#+END_SRC


Javascript stuff from mozilla for working with mozilla js source files.
Enabling eslint over jshint for flycheck.

#+BEGIN_SRC emacs-lisp
  (defun js-mode-hacks ()
    (setq-local mode-name "JS")
    ;; Set this locally so that the head.js rule continues to work
    ;; properly.  In particular for a mochitest we want to preserve the
    ;; "browser_" prefix.
    (when (buffer-file-name)
      (let ((base (file-name-nondirectory (buffer-file-name))))
        (when (string-match "^\\([a-z]+_\\)" base)
          (setq-local flycheck-temp-prefix (match-string 1 base))))
      (let ((base-dir (locate-dominating-file (buffer-file-name)
                                              ".eslintignore")))
        (when base-dir
          (let ((eslint (expand-file-name
                         "tools/lint/eslint/node_modules/.bin/eslint" base-dir)))
            (when (file-exists-p eslint)
              (setq-local flycheck-javascript-eslint-executable eslint))))))
    (flycheck-mode 1))

  (add-hook 'js2-mode-hook #'js-mode-hacks)
  (add-hook 'js2-mode-hook
            (lambda ()
              (setq
               js-indent-level 2
               indent-tabs-mode nil)))
#+END_SRC
** Web-mode
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :init (add-hook 'web-mode-hook
                    (lambda ()
                      (setq web-mode-markup-indent-offset 2)
                      (setq web-mode-css-indent-offset 2)
                      (setq web-mode-code-indent-offset 2))))

  (add-to-list 'auto-mode-alist '("\\.hbs\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.styl\\'" .web-mode))
#+END_SRC
* Org-mode configuration

This section contains all of the configuration for org-mode and org-mode related
settings for emacs. This is mostly based and tweeked from [[http://doc.norang.ca/org-mode.html][Org Mode - Organize Your Life In Plain Text!]] which is an amazing resource for org-mode from Bernt Hansen.

Set base directory and default notes file.

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/.emacs.d/org")
(setq org-default-notes-file "~/.emacs.d/org/refile.org")
#+END_SRC

** Outline of usage

I have several different files that I use to organize things in org-mode for. The default file that everything goes into is refile.org.
Here everything goes in during the day so that I can quickly add notes, tasks and everything else that one could think about. Everything
in this file is eventually put into the correct file for archiving and context.

*** Task Files
The current files that I use for organizing files which can be seen in the table below.
All task files reside in the "~/.emacs.d/org/tasks" directory.

|-------------+------------------------------------------------------------------|
| Filename    | Description                                                      |
|-------------+------------------------------------------------------------------|
| work.org    | Tasks relating to work                                           |
| home.org    | Personal tasks for example stuff that I need to get done at home |
|-------------+------------------------------------------------------------------|

*** Drill files
I use drill for studying and spaced repetition learning. All of these files resides in "~/.emacs.d/org/drill"

|--------------------+--------------------------------------------------------------|
| Filename           | Description                                                  |
|--------------------+--------------------------------------------------------------|
| presidents.org     | Learning the name and chronology of United States Presidents |
| eng_vocabulary.org | Expanding my english vocabulary                              |
|--------------------+--------------------------------------------------------------|

*** Notes files
General notes file for journaling, meetings and book notes. All of these files reside in
"~/.emacs.d/org/notes"

|--------------+----------------|
| Filename     | Description    |
|--------------+----------------|
| meetings.org | Meetings notes |
| journal.org  | Journal        |
| books.org    | Book notes     |
| papers.org   | Paper notes    |
|--------------+----------------|

** General Configuration
Keymappings for org-mode can be found in the [[*Keymappings][Keymappings]] part of this file.

*** Agenda setup
Agenda files is all files in the tasks directory

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files '("~/.emacs.d/org/tasks"
                           "~/.emacs.d/org/drill"
                           "~/.emacs.d/org/notes/notes.org"
                           "~/.emacs.d/org/refile.org"))
#+END_SRC

** Tasks and States

Some basic configuration

#+BEGIN_SRC emacs-lisp
(setq org-log-done 'time)
(setq org-use-fast-todo-selection t)
(setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+END_SRC

The last s-expression in the above source code lets us change the state with S-left and S-right without changing or adding timestamps etc.

Different todo states for different work places / bug trackers etc.

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)" "|" "DONE(d)")
        (sequence "Assigned" "WIP" "Review-" "Review?" "Review+" "Checkin" "|" "Pushed")
        (sequence "In Progress" "|" "Published")
        (sequence "Not Read" "Reading" "|" "Read")))
#+END_SRC

** Agenda

I've started working with TODOs more and more and org-agenda is of course great for customizing.
Below is a custom agenda command that only shows tasks that have been tagged with my place of work
so that I can focus on them when I work.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-custom-commands
        '(("w" "Work Tasks" tags-todo "expressen"
           ((org-agenda-files '("~/.emacs.d/org/tasks/work.org" "~/.emacs.d/org/tasks/refile.org"))))))
#+END_SRC
** Capture templates

Here we configure a fast way to get new tasks, notes etc. into our files using org-capture.
Entering `C-c c` we will choose one of the defined templates below and then with `C-c C-c` the new note or task will be created and placed in the appropriate file. Most captures just go into the refile file for later refiling to the appropriate file. This is for quick capturing of new stuff that comes in so as to not break up my workflow all to much.

Mote information about templates are found at: [[http://orgmode.org/manual/Capture-templates.html][Capture Templates at orgmode.org]]

The current templates that exists are:

  - A new task (t)
    Captures a new todo item task
  - A new journal entry (j)
    Captures a new journal entry
  - A new code snippet (c)
    Captures the selected region for a new code snippet

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        (quote (("t"
                 "todo"
                 entry
                 (file "~/.emacs.d/org/tasks/refile.org")
                 "* TODO %? %^g\n%U\n%a\n"
                 :clock-in t
                 :clock-resume t)
                ("j"
                 "Journal"
                 entry
                 (file+datetree "~/.emacs.d/org/notes/journal.org")
                 "* %?\n%U\n"
                 :clock-in t
                 :clock-resume t)
                ("c"
                 "Code Snippet"
                 entry
                 (file "~/.emacs.d/org/snippets.org")
                 "** Snippet: %l\n#+BEGIN_SRC %?\n%i\n#+END_SRC"
                 :clock-in t
                 :clock-resume t))))
#+END_SRC

*** TODO Make the code snippets go into the snippet file under the correct heading by default

    My snippets file is organized with the languages as the top level heading.
    Currently all new snippets first go into the refile file and later refiled under the
    correct language header. It would be neat to get it in under the correct heading directly.

    My guess is that we can use the file+function feature of the template and build a custom
    function that will find the correct headline someway.

    Crude first idea is to just prompt the user for a headline and then go to that headline.

** Refile setup

#+BEGIN_SRC emacs-lisp
(setq org-refile-targets '((nil :maxlevel . 9)
                           (org-agenda-files :maxlevel . 9)))
(setq org-refile-use-outline-path t)
(setq org-refile-allow-creating-parent-nodes (quote confirm))
(setq org-completion-use-ido t)
(setq ido-default-buffer-method 'selected-window)
(setq ido-default-file-method 'selected-window)
(setq org-indirect-buffer-display 'current-window)

(defun refile/verify-refile-target ()
  "Exclude todo keywords with a done state from refile targets"
  (not (member (nth 2 (org-heading-components)) org-done-keywords)))
(setq org-refile-target-verify-function 'refile/verify-refile-target)
#+END_SRC

** Org-drill
Drill mode is used for spaced repetition learning.

#+BEGIN_SRC emacs-lisp
(use-package org-drill
  :config (progn
            (add-to-list 'org-modules 'org-drill)
            (setq org-drill-add-random-noise-to-intervals-p t)
            (setq org-drill-hint-separator "||")
            (setq org-drill-left-cloze-delimiter "<[")
            (setq org-drill-right-cloze-delimiter "]>")
            (setq org-drill-learn-fraction 0.25)))
#+END_SRC

*** org-preview-latex-fragment fix
The function “org-preview-latex-fragment” was deprecated a while back, but org-drill still depends on it. So here’s a quick hack that will display the LaTeX in org-drill.

#+BEGIN_SRC emacs-lisp
(defun org-preview-latex-fragment ()
  (interactive)
  (org-remove-latex-fragment-image-overlays)
  (org-toggle-latex-fragment '(4)))
#+END_SRC

* TeX and LaTeX
Force the use of pdflatex (will fail if pdflatex is not installed).

#+BEGIN_SRC emacs-lisp
(setq latex-run-command "pdflatex")
(setq text-output-extension ".pdf")
#+END_SRC
* Notmuch (mail)
#+BEGIN_SRC emacs-lisp
  (use-package notmuch
    :init
    (progn
      (setq mail-host-address "pagefault.se")
      (setq user-full-name "Eric Skoglund")
      (setq user-mail-adress "eric@pagefault.se")
      (setq mail-user-agent 'message-user-agent)
      (setq message-send-mail-function 'message-send-mail-with-sendmail)
      (setq message-kill-buffer-on-exit t)
      (setq mail-specify-envelope-from t)
      (setq sendmail-program "/usr/bin/msmtp"
            mail-specify-envelope-from t
            mail-envelope-from 'header
            message-sendmail-envelope-from 'header)
      (setq notmuch-crypto-process-mime t))
    :config
    (setq notmuch-saved-searches
          '((:name "inbox"
                   :query "tag:inbox"
                   :count-query "tag:inbox and tag:unread"
                   :key "i")
            (:name "unread"
                   :query "tag:unread"
                   :key "u"
                   :count-query "tag:unread")
            (:name "flagged"
                   :query "tag:flagged"
                   :key "f"
                   :count-query "tag:flagged and tag:unread")
            (:name "drafts"
                   :query "tag:draft"
                   :count-query "tag:draft"
                   :key "d")
            (:name "all mail"
                   :query "*"
                   :count-query "*"
                   :key "a")
            (:name "emacs-devel-unread"
                   :query "tag:lists and +emacs-devel and tag:unread"
                   :count-query "tag:lists and +emacs-devel and tag:unread"
                   :key "em")
            (:name "emacs-bugs"
                   :query "tag:lists/bug-gnu-emacs and tag:unread"
                   :count-query "tag:lists/bug-gnu-emacs and tag:unread"
                   :key "eb")
            (:name "erlang-questions"
                   :query "tag:lists/erlang-questions and tag:unread"
                   :count-query "tag:lists/erlang-questions and tag:unread"
                   :key "erl")
            (:name "foss-sthlm"
                   :query "tag:lists/lists/foss-sthlm and tag:unread"
                   :count-query "tag:lists/lists/foss-sthlm and tag:unread"
                   :key "fs"))))
#+END_SRC
* Elfeed
#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :bind (("C-x w" . elfeed))
    :config
    (setq elfeed-feeds
          '("http://nullprogram.com/feed/"
            "http://www.tedunangst.com/flak/rss"
            "https://jeremykun.com/feed/"
            "https://pagefault.se/atom.xml"
            "https://krebsonsecurity.com/feed/"
            "https://www.schneier.com/blog/atom.xml")))
#+END_SRC
* Magit

We'll make all our interactions with magit begin with `C-c v`. Need to look into how
you bind keys for custom aliases.

#+BEGIN_SRC emacs-lisp
    (use-package magit
      :bind (("C-c v b" . magit-blame)
             ("C-c v c" . magit-branch-and-checkout)
             ("C-c v l" . magit-log)
             ("C-c v m" . magit-merge)
             ("C-c v o" . magit-checkout)
             ("C-c v p" . magit-pull)
             ("C-c v s" . magit-status)))
#+END_SRC
